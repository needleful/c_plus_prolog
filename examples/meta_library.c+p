% A file with some common meta stuff.

% Compile-time loop.
% Usage could be something like
% forall(Name: [a, b, c]) do (Name += 1).
% It only runs on terms that exist in the list,
% so it's ripe with opportunity to do some horrible things.
forall(Bind: List) do Body *=> statement_fold(S, NList) :-
	findall(Body, member(Bind, List), [S|NList]).

% Turn a Prolog list into C statements
statement_fold(S, []) *=> S.
statement_fold(S, [N|NList]) *=> statement_fold(S;N, NList).

% Good old 'nameof'. Everybody needs it.
% Various macros have to reject variables with \+var(X),
% or the variable will get initialized early.
nameof(Exp) *=> String :- \+var(Exp), sformat(String, "~w", Exp).

% A macro that returns the same syntax as before, but records the type info
% uses a compiler-provided dynamic predicate custom_data/1.
(struct Name => Body) *=> (struct Name => Body) :-
	% Now we have to prevent this macro from running again
	% otherwise it loops infinitely because the syntax is the same.
	\+ custom_data(inspected_struct(Name)),
	format("Inspecting: ~w~n", [Name]),
	(var_tuples(Body, []) *=> FieldTuples),
	assertz(custom_data(inspected_struct(Name))),
	assertz(Name.fields *=> FieldTuples).

var_tuples(A;B, List) *=> Result :- 
	(var_tuple(A, List) *=> List2),
	(var_tuples(B, List2) *=> Result).
var_tuples(Final, List) *=> var_tuple(Final, List).

var_tuple(T var N, List) *=> List2 :-
	(	atom(N),
		R = [(T, N)]
	;	N = (Name = _),
		R = [(T, Name)]
	;	N = (_,_),
		(var_tuple_multi(T, N, []) *=> R)
	),
	append(List, R, List2).
% Ignore anything that's not a variable.
var_tuple(_, List) *=> List.

var_tuple_multi(T, (V,Next), List) *=> var_tuple_multi(T, Next, List2) :-
	!,
	append(List, [(T, V)], List2).
var_tuple_multi(T, V, List) *=> var_tuple(T var V, List).
