% A file with some common meta stuff.

% Compile-time loop.
% Usage could be something like
% forall(Name: [a, b, c]) do (Name += 1).
% It only runs on terms that exist in the list,
% so it's ripe with opportunity to do some horrible things.
forall(Bind: List) do Body *=> statement_fold(S, NList) :-
	findall(Body, member(Bind, List), [S|NList]).

% Turn a Prolog list into C statements
statement_fold(S, []) *=> S.
statement_fold(S, [N|NList]) *=> statement_fold(S;N, NList).

% Good old 'nameof'. Everybody needs it.
% Various macros have to reject variables with \+var(X),
% or the variable will get initialized early.
nameof(Exp) *=> String :- \+var(Exp), sformat(String, "~w", Exp).

% A tag to give you compile-time information about a struct
% Used like `inspect@ struct my_struct`
(inspect@ Decl => Body) *=> (Decl=>Body) :-
	(strip_attrib(Decl) *=> struct Name),
	(var_tuples(Body, []) *=> FieldTuples),
	asserta((inspected_struct(Name) *=> true :- !)),
	assertz(Name.fields *=> FieldTuples).

inspected_struct(_) *=> false, !.

strip_attrib(_@ Body) *=> strip_attrib(Body).
strip_attrib(Bare) *=> Bare.

var_tuples(A;B, List) *=> Result :- 
	(var_tuple(A, List) *=> List2),
	(var_tuples(B, List2) *=> Result).
var_tuples(Final, List) *=> var_tuple(Final, List).

var_tuple(T var N, List) *=> List2 :-
	(	atom(N),
		R = [(T, N)]
	;	N = (Name = _),
		R = [(T, Name)]
	;	N = (_,_),
		(var_tuple_multi(T, N, []) *=> R)
	),
	append(List, R, List2).

var_tuple_multi(T, (V,Next), List) *=> var_tuple_multi(T, Next, List2) :-
	!,
	append(List, [(T, V)], List2).
var_tuple_multi(T, V, List) *=> var_tuple(T var V, List).
