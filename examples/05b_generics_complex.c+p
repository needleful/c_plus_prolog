:- include(ctype, stdbool, stdio, stdlib, string).

% Poor man's generics
struct int:list.
struct char:ptr:list.

func main =>
	int var size = 12;
	int:list var myInts = int:list.new(size);
	for(int var i = 0; i < size; i += 1) do (
		int:list.append(myInts, i*i)
	);
	for(int var i = 0; i < size; i+= 1) do (
		printf("%d squared = %d.\n", i, int:list.get(myInts, i))
	).

struct T:list =>
	T:ptr:ptr var items;

	(size_t:ptr func capacity =>
		return this.items
			then (@this.items as size_t:ptr) - 2
			else 0
	);

	(size_t:ptr func length =>
		return this.items 
			then (@this.items as size_t:ptr) - 1
			else 0
	);

	(static@ 
	T:list func new(size_t var capacity) =>
		T:list var this;
		this.items = malloc(sizeof(T:ptr:ptr)) as T:ptr:ptr;
		void:ptr var raw_data = malloc(sizeof(T)*capacity + sizeof(size_t)*2);
		@this.items = & (raw_data as size_t:ptr)[2] as T:ptr;
		@T:list.capacity(this) = capacity;
		@T:list.length(this) = 0;
		return this
	);

	(func resize(size_t var new_capacity) =>
		void:ptr var raw_data = realloc(
			T:list.capacity(this) as void:ptr, 
			sizeof(T)*new_capacity + sizeof(size_t)*2);
		@this.items = (raw_data as size_t:ptr) + 2 as T:ptr;
		@T:list.capacity(this) = new_capacity
	);

	(func clear =>
		free(T:list.capacity(@this));
		free(this->items);
		this->items = 'NULL'
	);

	(T:ptr func at(size_t var id) =>
		return @this.items+id
	);

	(T func get(size_t var id) =>
		return @T:list.at(this, id)
	);

	(func append(T var item) =>
		!this.items then (
			puts("Internal error. List was not allocated properly.");
			return
		)
		else (!@this.items) then (
			@this.items = @T:list.new(1).items
		);
		size_t var length = @T:list.length(this);
		size_t var capacity = @T:list.capacity(this);
		length >= capacity then 
			T:list.resize(this, capacity*2);
		@T:list.at(this, length) = item;
		@T:list.length(this) += 1
	);

	(T func pop =>
		(!this.items or !@this.items or @T:list.length(this) =< 0) then (
			puts("Error: Popped empty list.");
			T var junk = 0 as T;
			return junk
		)
		else (
			size_t:ptr var l = T:list.length(this);
			@l -= 1;
			return (@this.items)[@l]
		)
	).

T:list *=> ListType :-
	(mangled_name(T) *=> MT),
	atom_concat('gen_list_', MT, ListType).

mangled_name(Type) *=> Renamed :- 
	(	atom(Type)
	->	Renamed = Type
	;	(mangle_concat('', Type) *=> Renamed)
	).

mangle_concat(Atom, Next) *=> R :-
	(	atom(Next)
	->	atom_concat(Atom, Next, R)
	;	Atom2:Name = Next,
		atom_concat(Atom, Atom2, Atom3),
		(mangle_concat(Atom3, Name) *=> R)
	).

method_name(Struct, Func) *=> SName :-
	atom_concat(Struct, '_', Name2),
	atom_concat(Name2, Func, SName).

(SType, Func).Method *=> SMethod :- 
	(	atom(SType)
	->	Struct = SType
	;	Struct:_ = SType
	),
	(	Method = method,
		Args = []
	;	compound(Method),
		Method =.. [method|Args]
	),
	(method_name(Struct, Func) *=> SName),
	SMethod =.. [SName, SType var this|Args].

(SType, Func).Call *=> SCall :- 
	(	atom(SType)
	->	Struct = SType
	;	Struct:_ = SType
	),
	(	Call = call,
		Args = []
	;	compound(Call),
		Call =.. [call|Args]
	),
	(method_name(Struct, Func) *=> SName),
	SCall =.. [SName|Args].